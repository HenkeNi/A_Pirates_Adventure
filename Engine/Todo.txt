How to handle Camera?



Application				/		Engine						/		Scene

all scenes share			all applications share				unique per scene

								




Scene => directly or as an GameObject?

Reference to a camera in engine/application?? => 
 



Every scene contains a gameobject that is the camera...







* Opt 1; 
	- Every scene contains a camera... (or maybe Application? -> pass it in shared context?)
	- Passed with RenderData to the renderer; SpriteRenderer::Render(someData, Camera);
	- C_CameraController component => have the ability to move or transform the camera...


* Opt 2;
	- Camera is always a component 
	- when camera is activated it sets itself as camera in the renderer 
	-	gameobject has pointer to its scene?? 


* Opt 3;
	- Camera lives in engine
	- C_Camera component controlls the camera (How? -> static member?)


* Opt 4;
	- Graphics.h contains a camera?


Scene always adds a camera game object`??





where to put camera?
	-> graphics?
	-> engine?
	-> just inherit from it when needed? (component)
	-> application (needed to render a scene?)
	-> renderer?

	bind camear to renderer??
	´pass in when rendering?=



	Scebe has a camera or at least a camera component? 


	C_CameraController?



### GAMEPLAY ###

-> Control with keys or by pressing mouse button (diablo style)? 



## Rendering ##
* use glCreate rather then glGen? => (glGenTexture vs glCreateTexture)?

render cómmand?



# Animations #
blend between textures? => mayebe bad idea?...



Commands??




GameObject can send a position set message to its components...
	only Transform listens...?? -> sets new position...


	particles in engine





	entity events?
		- spawned, despawned (destroyed), colliding_x, collind-Y,
		moving-left, became_idle, began-moving


Engine

* Memory Folder???
	* Allocater instead of memory pool!?




* Maybe put SceneManager and Scene.h in Engine?? Also consider putting GameObject and Component.h in Engine as well?? -> remains the same for all projects...




do all reading of json in Engine??



Have Contains functions return a struct 

template <typename T>
struct RESULT
{	
	bool m_contains;
	T* result;
}




* Utility
	- Perlin noise (1D)







In Game??
TimeManager?? Or extend CommonUtilities Timer.h???
	* RegisterCallback(float aTime, std::function<void()> aCallback)	->	 a callback that gets executed after x seconds/timespan
	* Notify															->  notify after timespan (returns a bool)



In Game: 
	DateManager() 






Make a Range class??



When to update delta time... 
	- at the end of the game loop??

	Fixed time steps?


	Run messag /event queue (?) at the end of the loop? 
		(at the end of the update loop -> so end of LateUpdate()?? )

		Event Queue -> all events get stored in a Queue (and sorted after priority) ??



Polling vs Pushing;

	-> attack? -> sword sends message? check if collides with anything...??





	Maybe put GameObject in Engine (as well as Component - base)
		and the rest inside the Game??